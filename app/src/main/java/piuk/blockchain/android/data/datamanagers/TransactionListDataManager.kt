package piuk.blockchain.android.data.datamanagers

import info.blockchain.wallet.payload.PayloadManager
import info.blockchain.wallet.util.FormatsUtil
import io.reactivex.Observable
import io.reactivex.Single
import piuk.blockchain.android.data.bitcoincash.BchDataManager
import piuk.blockchain.android.data.currency.CryptoCurrencies
import piuk.blockchain.android.data.currency.CurrencyState
import piuk.blockchain.android.data.ethereum.EthDataManager
import piuk.blockchain.android.data.rxjava.RxUtil
import piuk.blockchain.android.data.stores.TransactionListStore
import piuk.blockchain.android.data.transactions.BchDisplayable
import piuk.blockchain.android.data.transactions.BtcDisplayable
import piuk.blockchain.android.data.transactions.Displayable
import piuk.blockchain.android.data.transactions.EthDisplayable
import piuk.blockchain.android.ui.account.ItemAccount
import piuk.blockchain.android.util.annotations.Mockable
import timber.log.Timber
import java.util.*

@Mockable
class TransactionListDataManager(
        private val payloadManager: PayloadManager,
        private val ethDataManager: EthDataManager,
        private val bchDataManager: BchDataManager,
        private val transactionListStore: TransactionListStore,
        private val currencyState: CurrencyState
        ) {

    fun fetchTransactions(itemAccount: ItemAccount, limit: Int, offset: Int): Observable<List<Displayable>> {

        val observable: Observable<List<Displayable>> = when (currencyState.cryptoCurrency) {
            CryptoCurrencies.BTC -> fetchBtcTransactions(itemAccount, limit, offset)
            CryptoCurrencies.ETHER -> getEthereumObservable()
            CryptoCurrencies.BCH -> fetchBchTransactions(itemAccount, limit, offset)
        }

        return observable.doOnNext { insertTransactionList(it.toMutableList()) }
                .map { transactionListStore.list }
                .doOnError { emptyList<Displayable>() }
                .compose(RxUtil.applySchedulersToObservable())
    }

    internal fun fetchBtcTransactions(itemAccount: ItemAccount, limit: Int, offset: Int): Observable<List<Displayable>> {

        return when (itemAccount.type) {
            ItemAccount.TYPE.ALL_ACCOUNTS_AND_LEGACY -> getAllTransactionsObservable(limit, offset)
            ItemAccount.TYPE.ALL_LEGACY -> getLegacyObservable(limit, offset)
            ItemAccount.TYPE.SINGLE_ACCOUNT -> getAccountObservable(itemAccount.address!!, limit, offset)
        }
    }

    internal fun fetchBchTransactions(itemAccount: ItemAccount, limit: Int, offset: Int): Observable<List<Displayable>> {

        val txs =  when (itemAccount.type) {
            ItemAccount.TYPE.ALL_ACCOUNTS_AND_LEGACY -> getBchAllTransactionsObservable(limit, offset)
            ItemAccount.TYPE.ALL_LEGACY -> getBchLegacyObservable(limit, offset)
            ItemAccount.TYPE.SINGLE_ACCOUNT -> getBchAccountObservable(itemAccount.address!!, limit, offset)
        }

        return txs
    }

    /**
     * Returns a list of [Displayable] objects generated by [getTransactionList]
     *
     * @return A list of Txs sorted by date.
     */
    fun getTransactionList(): List<Displayable> = transactionListStore.list

    /**
     * Resets the list of Transactions.
     */
    fun clearTransactionList() {
        transactionListStore.clearList()
    }

    /**
     * Allows insertion of a single new [Displayable] into the main transaction list.
     *
     * @param transaction A new, most likely temporary [Displayable]
     * @return An updated list of Txs sorted by date
     */
    fun insertTransactionIntoListAndReturnSorted(transaction: Displayable): List<Displayable> {
        transactionListStore.insertTransactionIntoListAndSort(transaction)
        return transactionListStore.list
    }

    /**
     * Get total BTC balance from [ItemAccount].
     *
     * @param itemAccount [ItemAccount]
     * @return A BTC value as a long.
     */
    fun getBtcBalance(itemAccount: ItemAccount): Long {
        return when (itemAccount.type) {
            ItemAccount.TYPE.ALL_ACCOUNTS_AND_LEGACY -> payloadManager.walletBalance.toLong()
            ItemAccount.TYPE.ALL_LEGACY -> payloadManager.importedAddressesBalance.toLong()
            ItemAccount.TYPE.SINGLE_ACCOUNT -> payloadManager.getAddressBalance(itemAccount.address).toLong()
        }
    }

    /**
     * Get total BCH balance from [ItemAccount].
     *
     * @param itemAccount [ItemAccount]
     * @return A BCH value as a long.
     */
    fun getBchBalance(itemAccount: ItemAccount): Long {
        return when (itemAccount.type) {
            ItemAccount.TYPE.ALL_ACCOUNTS_AND_LEGACY ->
                (bchDataManager.getWalletBalance() + bchDataManager.getImportedAddressBalance()).toLong()
            ItemAccount.TYPE.ALL_LEGACY -> bchDataManager.getImportedAddressBalance().toLong()
            ItemAccount.TYPE.SINGLE_ACCOUNT -> bchDataManager.getAddressBalance(itemAccount.address!!).toLong()
        }
    }

    /**
     * Get a specific [Displayable] from a hash
     *
     * @param transactionHash The hash of the Tx to be returned
     * @return An Observable object wrapping a Tx. Will call onError if not found with a
     * NullPointerException
     */
    fun getTxFromHash(transactionHash: String): Single<Displayable> =
            Observable.fromIterable(getTransactionList())
                    .filter { it.hash == transactionHash }
                    .firstOrError()

    /**
     * Returns a [HashMap] where a [Displayable] hash is used as a key against
     * the confirmation number. This is for displaying the confirmation number in the Contacts page.
     * Please note that this is deliberately not cleared when switching accounts.
     */
    fun getTxConfirmationsMap(): HashMap<String, Int> = transactionListStore.txConfirmationsMap

    private fun insertTransactionList(txList: MutableList<Displayable>) {
        val pendingTxs = getRemainingPendingTransactionList(txList)
        clearTransactionList()
        txList.addAll(pendingTxs)
        transactionListStore.insertTransactions(txList)
    }

    /**
     * Gets list of transactions that have been published but delivery has not yet been confirmed.
     */
    private fun getRemainingPendingTransactionList(newlyFetchedTxs: List<Displayable>): List<Displayable> {
        val pendingMap = HashMap<String, Displayable>()
        transactionListStore.list
                .filter { it.isPending }
                .forEach { pendingMap.put(it.hash, it) }

        if (!pendingMap.isEmpty()) {
            filterProcessed(newlyFetchedTxs, pendingMap)
        }

        return ArrayList(pendingMap.values)
    }

    private fun filterProcessed(
            newlyFetchedTxs: List<Displayable>,
            pendingMap: HashMap<String, Displayable>
    ) {
        newlyFetchedTxs.filter { pendingMap.containsKey(it.hash) }
                .forEach { pendingMap.remove(it.hash) }
    }

    private fun getAllTransactionsObservable(limit: Int, offset: Int): Observable<List<Displayable>> =
            Observable.fromCallable {
                payloadManager.getAllTransactions(limit, offset)
                        .map { BtcDisplayable(it) }
            }

    private fun getLegacyObservable(limit: Int, offset: Int): Observable<List<Displayable>> =
            Observable.fromCallable {
                payloadManager.getImportedAddressesTransactions(limit, offset)
                        .map { BtcDisplayable(it) }
            }

    private fun getAccountObservable(address: String, limit: Int, offset: Int): Observable<List<Displayable>> =
            Observable.fromCallable {
                payloadManager.getAccountTransactions(address, limit, offset)
                        .map { BtcDisplayable(it) }
            }

    private fun getEthereumObservable(): Observable<List<Displayable>> = ethDataManager.getLatestBlock()
            .flatMap { latestBlock ->
                ethDataManager.getEthTransactions()
                        .map {
                            EthDisplayable(
                                    ethDataManager.getEthResponseModel()!!,
                                    it,
                                    latestBlock.blockHeight
                            )
                        }.toList()
                        .toObservable()
            }

    private fun getBchAllTransactionsObservable(limit: Int, offset: Int): Observable<List<Displayable>> =
            Observable.fromCallable {
                bchDataManager.getWalletTransactions(limit, offset)!!
                        .map { BchDisplayable(it) }
            }

    private fun getBchLegacyObservable(limit: Int, offset: Int): Observable<List<Displayable>> =
            Observable.fromCallable {
                bchDataManager.getImportedAddressTransactions(limit, offset)!!
                        .map { BchDisplayable(it) }
            }

    private fun getBchAccountObservable(address: String, limit: Int, offset: Int): Observable<List<Displayable>> =
            Observable.fromCallable {
                bchDataManager.getAddressTransactions(address, limit, offset)!!
                        .map { BchDisplayable(it) }
            }
}
