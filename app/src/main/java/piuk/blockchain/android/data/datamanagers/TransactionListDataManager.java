package piuk.blockchain.android.data.datamanagers;

import android.support.annotation.NonNull;

import info.blockchain.wallet.multiaddress.TransactionSummary;
import info.blockchain.wallet.payload.PayloadManager;
import info.blockchain.wallet.util.FormatsUtil;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import io.reactivex.Observable;
import piuk.blockchain.android.data.rxjava.RxBus;
import piuk.blockchain.android.data.rxjava.RxUtil;
import piuk.blockchain.android.data.stores.TransactionListStore;
import piuk.blockchain.android.ui.account.ItemAccount;

public class TransactionListDataManager {

    private PayloadManager payloadManager;
    private TransactionListStore transactionListStore;
    private RxBus rxBus;

    public TransactionListDataManager(PayloadManager payloadManager,
                                      TransactionListStore transactionListStore,
                                      RxBus rxBus) {
        this.payloadManager = payloadManager;
        this.transactionListStore = transactionListStore;
        this.rxBus = rxBus;
    }

    public Observable<List<TransactionSummary>> fetchTransactions(ItemAccount itemAccount, int limit, int offset) {
        return Observable.fromCallable(() -> {
            List<TransactionSummary> result;

            switch (itemAccount.getType()) {
                case ALL_ACCOUNTS_AND_LEGACY:
                    result = payloadManager.getAllTransactions(limit, offset);
                    break;
                case ALL_LEGACY:
                    result = payloadManager.getImportedAddressesTransactions(limit, offset);
                    break;
                default:
                    if (FormatsUtil.isValidXpub(itemAccount.getAddress())) {
                        result = payloadManager.getAccountTransactions(itemAccount.getAddress(), limit, offset);
                    } else {
                        result = payloadManager.getImportedAddressesTransactions(limit, offset);
                    }
            }

            insertTransactionList(result);

            return transactionListStore.getList();
        }).compose(RxUtil.applySchedulersToObservable());
    }

    /**
     * Returns a list of {@link TransactionSummary} objects generated by {@link
     * #getTransactionList()}
     *
     * @return A list of Txs sorted by date.
     */
    @NonNull
    public List<TransactionSummary> getTransactionList() {
        return transactionListStore.getList();
    }

    /**
     * Resets the list of Transactions.
     */
    public void clearTransactionList() {
        transactionListStore.clearList();
    }

    /**
     * Allows insertion of a single new {@link TransactionSummary} into the main transaction list.
     *
     * @param transaction A new, most likely temporary {@link TransactionSummary}
     * @return An updated list of Txs sorted by date
     */
    @NonNull
    public List<TransactionSummary> insertTransactionIntoListAndReturnSorted(TransactionSummary transaction) {
        transactionListStore.insertTransactionIntoListAndSort(transaction);
        return transactionListStore.getList();
    }

    /**
     * Get total BTC balance from {@link ItemAccount}.
     *
     * @param itemAccount {@link ItemAccount}
     * @return A BTC value as a long.
     */
    public long getBtcBalance(ItemAccount itemAccount) {
        switch (itemAccount.getType()) {
            case ALL_ACCOUNTS_AND_LEGACY:
                return payloadManager.getWalletBalance().longValue();
            case ALL_LEGACY:
                return payloadManager.getImportedAddressesBalance().longValue();
            case SINGLE_ACCOUNT:
                return payloadManager.getAddressBalance(itemAccount.getAddress()).longValue();
            default:
                return 0;
        }
    }

    /**
     * Get a specific {@link TransactionSummary} from a hash
     *
     * @param transactionHash The hash of the Tx to be returned
     * @return An Observable object wrapping a Tx. Will call onError if not found with a
     * NullPointerException
     */
    public Observable<TransactionSummary> getTxFromHash(String transactionHash) {
        return Observable.create(emitter -> {
            //noinspection Convert2streamapi
            for (TransactionSummary tx : getTransactionList()) {
                if (tx.getHash().equals(transactionHash)) {
                    if (!emitter.isDisposed()) {
                        emitter.onNext(tx);
                        emitter.onComplete();
                    }
                    return;
                }
            }

            if (!emitter.isDisposed()) emitter.onError(new NullPointerException("Tx not found"));
        });
    }

    /**
     * Returns a {@link HashMap} where a {@link TransactionSummary} hash is used as a key against
     * the confirmation number. This is for displaying the confirmation number in the Contacts page.
     * Please note that this is deliberately not cleared when switching accounts.
     */
    public HashMap<String, Integer> getTxConfirmationsMap() {
        return transactionListStore.getTxConfirmationsMap();
    }

    private void insertTransactionList(List<TransactionSummary> txList) {
        List<TransactionSummary> pendingTxs = getRemainingPendingTransactionList(txList);
        clearTransactionList();
        txList.addAll(pendingTxs);
        transactionListStore.insertTransactions(txList);
        rxBus.emitEvent(List.class, transactionListStore.getList());
    }

    /**
     * Gets list of transactions that have been published but delivery has not yet been confirmed.
     */
    private List<TransactionSummary> getRemainingPendingTransactionList(List<TransactionSummary> newlyFetchedTxs) {
        HashMap<String, TransactionSummary> pendingMap = new HashMap<>();
        for (TransactionSummary transactionSummary : transactionListStore.getList()) {
            if (transactionSummary.isPending()) {
                pendingMap.put(transactionSummary.getHash(), transactionSummary);
            }
        }

        if (!pendingMap.isEmpty()) {
            filterProcessed(newlyFetchedTxs, pendingMap);
        }

        return new ArrayList<>(pendingMap.values());
    }

    private void filterProcessed(List<TransactionSummary> newlyFetchedTxs, HashMap<String, TransactionSummary> pendingMap) {
        for (TransactionSummary tx : newlyFetchedTxs) {
            if (pendingMap.containsKey(tx.getHash())) {
                pendingMap.remove(tx.getHash());
            }
        }
    }

}
