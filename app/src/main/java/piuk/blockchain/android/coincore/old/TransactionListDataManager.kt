package piuk.blockchain.android.coincore.old

import com.blockchain.sunriver.XlmDataManager
import info.blockchain.balance.CryptoCurrency
import info.blockchain.wallet.payload.PayloadManager
import io.reactivex.Observable
import io.reactivex.Single
import io.reactivex.rxkotlin.Observables
import io.reactivex.schedulers.Schedulers
import piuk.blockchain.android.ui.account.ItemAccount
import piuk.blockchain.androidcore.data.bitcoincash.BchDataManager
import piuk.blockchain.androidcore.data.currency.CurrencyState
import piuk.blockchain.androidcore.data.erc20.Erc20Account
import piuk.blockchain.androidcore.data.erc20.FeedErc20Transfer
import piuk.blockchain.androidcore.data.ethereum.EthDataManager
import piuk.blockchain.android.coincore.model.TransactionListStore
import piuk.blockchain.android.coincore.model.BtcActivitySummaryItem
import piuk.blockchain.android.coincore.model.ActivitySummaryItem
import piuk.blockchain.android.coincore.model.Erc20ActivitySummaryItem
import piuk.blockchain.android.coincore.model.EthActivitySummaryItem
import piuk.blockchain.android.coincore.model.BchActivitySummaryItem
import piuk.blockchain.android.coincore.model.XlmActivitySummaryItem

typealias ActivitySummaryList = List<ActivitySummaryItem>

class TransactionListDataManager(
    private val payloadManager: PayloadManager,
    private val ethDataManager: EthDataManager,
    private val bchDataManager: BchDataManager,
    private val xlmDataManager: XlmDataManager,
    private val paxAccount: Erc20Account,
    private val transactionListStore: TransactionListStore,
    private val currencyState: CurrencyState
) {
    fun fetchTransactions(
        itemAccount: ItemAccount,
        limit: Int,
        offset: Int
    ): Single<ActivitySummaryList> =
        when (currencyState.cryptoCurrency) {
            CryptoCurrency.BTC -> fetchBtcTransactions(itemAccount, limit, offset)
            CryptoCurrency.ETHER -> getEthereumTransactions()
            CryptoCurrency.BCH -> fetchBchTransactions(itemAccount, limit, offset)
            CryptoCurrency.XLM -> fetchXlmTransactions()
            CryptoCurrency.PAX -> getPaxTransactions().onErrorReturn { emptyList() }
            CryptoCurrency.STX -> TODO("STUB: STX NOT IMPLEMENTED")
        }.doOnNext {
            insertTransactionList(it.toMutableList())
        }
        .map { transactionListStore.list }
        .doOnError { emptyList<ActivitySummaryItem>() }
        .subscribeOn(Schedulers.io())
        .singleOrError()

    private fun fetchXlmTransactions(): Observable<ActivitySummaryList> =
        xlmDataManager.getTransactionList()
            .toObservable()
            .mapList { XlmActivitySummaryItem(it) }

    private fun fetchBtcTransactions(
        itemAccount: ItemAccount,
        limit: Int,
        offset: Int
    ): Observable<ActivitySummaryList> =
        when (itemAccount.type) {
            ItemAccount.TYPE.ALL_ACCOUNTS_AND_LEGACY -> getAllBtcTransactions(limit, offset)
            ItemAccount.TYPE.ALL_LEGACY -> getLegacyBtcTransactions(limit, offset)
            ItemAccount.TYPE.SINGLE_ACCOUNT -> getBtcAccountTransactions(itemAccount.address!!, limit, offset)
        }

    private fun fetchBchTransactions(
        itemAccount: ItemAccount,
        limit: Int,
        offset: Int
    ): Observable<ActivitySummaryList> =
        when (itemAccount.type) {
            ItemAccount.TYPE.ALL_ACCOUNTS_AND_LEGACY -> getAllBchTransactions(limit, offset)
            ItemAccount.TYPE.ALL_LEGACY -> getLegacyBchTransactions(limit, offset)
            ItemAccount.TYPE.SINGLE_ACCOUNT -> getBchAccountTransactions(itemAccount.address!!, limit, offset)
        }

    /**
     * Returns a list of [ActivitySummaryItem] objects generated by [getTransactionList]
     *
     * @return A list of Txs sorted by date.
     */
    fun getTransactionList(): ActivitySummaryList = transactionListStore.list

    /**
     * Resets the list of Transactions.
     */
    fun clearTransactionList() {
        transactionListStore.clear()
    }

    /**
     * Get total BTC balance from [ItemAccount].
     *
     * @param itemAccount [ItemAccount]
     * @return A BTC value as a long.
     */
    fun getBtcBalance(itemAccount: ItemAccount): Long = when (itemAccount.type) {
        ItemAccount.TYPE.ALL_ACCOUNTS_AND_LEGACY -> payloadManager.walletBalance.toLong()
        ItemAccount.TYPE.ALL_LEGACY -> payloadManager.importedAddressesBalance.toLong()
        ItemAccount.TYPE.SINGLE_ACCOUNT -> payloadManager.getAddressBalance(itemAccount.address).toLong()
    }

    /**
     * Get total BCH balance from [ItemAccount].
     *
     * @param itemAccount [ItemAccount]
     * @return A BCH value as a long.
     */
    fun getBchBalance(itemAccount: ItemAccount): Long = when (itemAccount.type) {
        ItemAccount.TYPE.ALL_ACCOUNTS_AND_LEGACY -> bchDataManager.getWalletBalance().toLong()
        ItemAccount.TYPE.ALL_LEGACY -> bchDataManager.getImportedAddressBalance().toLong()
        ItemAccount.TYPE.SINGLE_ACCOUNT -> bchDataManager.getAddressBalance(itemAccount.address!!).toLong()
    }

    /**
     * Get a specific [ActivitySummaryItem] from a hash
     *
     * @param transactionHash The hash of the Tx to be returned
     * @return An Observable object wrapping a Tx. Will call onError if not found with a
     * NullPointerException
     */
    fun getTxFromHash(transactionHash: String): Single<ActivitySummaryItem> =
        Observable.fromIterable(getTransactionList())
            .filter { it.hash == transactionHash }
            .firstOrError()

    private fun insertTransactionList(txList: MutableList<ActivitySummaryItem>) {
        val pendingTxs = getRemainingPendingTransactionList(txList)
        clearTransactionList()
        txList.addAll(pendingTxs)
        transactionListStore.insertTransactions(txList)
    }

    /**
     * Gets list of transactions that have been published but delivery has not yet been confirmed.
     */
    private fun getRemainingPendingTransactionList(newlyFetchedTxs: ActivitySummaryList): ActivitySummaryList {
        val pendingMap = HashMap<String, ActivitySummaryItem>()
        transactionListStore.list
            .filter { it.isPending }
            .forEach { pendingMap[it.hash] = it }

        if (pendingMap.isNotEmpty()) {
            filterProcessed(newlyFetchedTxs, pendingMap)
        }

        return ArrayList(pendingMap.values)
    }

    private fun filterProcessed(
        newlyFetchedTxs: ActivitySummaryList,
        pendingMap: HashMap<String, ActivitySummaryItem>
    ) {
        newlyFetchedTxs.filter { pendingMap.containsKey(it.hash) }
            .forEach { pendingMap.remove(it.hash) }
    }

    private fun getAllBtcTransactions(
        limit: Int,
        offset: Int
    ): Observable<ActivitySummaryList> =
        Observable.fromCallable {
            payloadManager.getAllTransactions(limit, offset)
                .map {
                    BtcActivitySummaryItem(
                        it
                    )
                }
        }

    private fun getLegacyBtcTransactions(limit: Int, offset: Int): Observable<ActivitySummaryList> =
        Observable.fromCallable {
            payloadManager.getImportedAddressesTransactions(limit, offset)
                .map {
                    BtcActivitySummaryItem(
                        it
                    )
                }
        }

    private fun getBtcAccountTransactions(
        address: String,
        limit: Int,
        offset: Int
    ): Observable<List<ActivitySummaryItem>> =
        Observable.fromCallable {
            payloadManager.getAccountTransactions(address, limit, offset)
                .map {
                    BtcActivitySummaryItem(
                        it
                    )
                }
        }

    private fun getEthereumTransactions(): Observable<ActivitySummaryList> =
        ethDataManager.getLatestBlock()
            .flatMap { latestBlock ->
                ethDataManager.getEthTransactions()
                    .map {
                        val ethFeeForPaxTransaction =
                            it.to.equals(ethDataManager.getErc20TokenData(CryptoCurrency.PAX).contractAddress,
                                ignoreCase = true)
                        EthActivitySummaryItem(
                            ethDataManager.getEthResponseModel()!!,
                            it,
                            ethFeeForPaxTransaction,
                            latestBlock.blockHeight
                        )
                    }.toList()
                    .toObservable()
            }

    private fun getPaxTransactions(): Observable<ActivitySummaryList> {
        val feedTransactions =
            paxAccount.getTransactions().mapList {
                val feeObservable = ethDataManager.getTransaction(it.transactionHash)
                    .map { transaction -> transaction.gasUsed * transaction.gasPrice }
                FeedErc20Transfer(it, feeObservable)
            }

        return Observables.zip(
            feedTransactions,
            paxAccount.getAccountHash(),
            ethDataManager.getLatestBlockNumber()
        ).map { (transactions, accountHash, latestBlockNumber) ->
            transactions.map { transaction ->
                Erc20ActivitySummaryItem(
                    transaction,
                    accountHash,
                    latestBlockNumber.number
                )
            }
        }
    }

    private fun getAllBchTransactions(
        limit: Int,
        offset: Int
    ): Observable<ActivitySummaryList> =
        bchDataManager.getWalletTransactions(limit, offset)
            .mapList {
                BchActivitySummaryItem(
                    it
                )
            }

    private fun getLegacyBchTransactions(limit: Int, offset: Int): Observable<ActivitySummaryList> =
        bchDataManager.getImportedAddressTransactions(limit, offset)
            .mapList {
                BchActivitySummaryItem(
                    it
                )
            }

    private fun getBchAccountTransactions(
        address: String,
        limit: Int,
        offset: Int
    ): Observable<List<ActivitySummaryItem>> =
        bchDataManager.getAddressTransactions(address, limit, offset)
            .mapList {
                BchActivitySummaryItem(
                    it
                )
            }

    private fun <T, R> Observable<List<T>>.mapList(func: (T) -> R): Observable<List<R>> {
        return flatMapIterable { list ->
            list.map { func(it) }
        }.toList().toObservable()
    }
}
