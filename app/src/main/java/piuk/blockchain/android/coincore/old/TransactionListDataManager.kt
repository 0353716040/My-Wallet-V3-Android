package piuk.blockchain.android.coincore.old

import io.reactivex.Observable
import io.reactivex.Single
import piuk.blockchain.android.coincore.model.TransactionListStore
import piuk.blockchain.android.coincore.model.ActivitySummaryItem

typealias ActivitySummaryList = List<ActivitySummaryItem>

class TransactionListDataManager(
    private val transactionListStore: TransactionListStore
) {
//    fun fetchTransactions(
//        cryptoCurrency: CryptoCurrency,
//        itemAccount: ItemAccount,
//        limit: Int = 50,
//        offset: Int = 0
//    ): Single<ActivitySummaryList> =
//        when (cryptoCurrency) {
//            CryptoCurrency.BTC -> TODO("MOVED!")
//            CryptoCurrency.ETHER -> TODO("MOVED!")
//            CryptoCurrency.BCH -> fetchBchTransactions(itemAccount, limit, offset)
//            CryptoCurrency.XLM -> fetchXlmTransactions()
//            CryptoCurrency.PAX -> getPaxTransactions().onErrorReturn { emptyList() }
//            CryptoCurrency.STX -> TODO("STUB: STX NOT IMPLEMENTED")
//        }.doOnNext {
//            insertTransactionList(it.toMutableList())
//        }
//        .map { transactionListStore.list }
//        .doOnError { emptyList<ActivitySummaryItem>() }
//        .subscribeOn(Schedulers.io())
//        .singleOrError()

//    /**
//     * Returns a list of [ActivitySummaryItem] objects generated by [getTransactionList]
//     *
//     * @return A list of Txs sorted by date.
//     */
//    fun getTransactionList(): ActivitySummaryList = transactionListStore.list
//
//    /**
//     * Resets the list of Transactions.
//     */
//    fun clearTransactionList() {
//        transactionListStore.clear()
//    }

// ONLY USED IN TESTS!
//    /**
//     * Get total BTC balance from [ItemAccount].
//     *
//     * @param itemAccount [ItemAccount]
//     * @return A BTC value as a long.
//     */
//    fun getBtcBalance(itemAccount: ItemAccount): Long = when (itemAccount.type) {
//        ItemAccount.TYPE.ALL_ACCOUNTS_AND_LEGACY -> payloadManager.walletBalance.toLong()
//        ItemAccount.TYPE.ALL_LEGACY -> payloadManager.importedAddressesBalance.toLong()
//        ItemAccount.TYPE.SINGLE_ACCOUNT -> payloadManager.getAddressBalance(itemAccount.address).toLong()
//    }
//
//    /**
//     * Get total BCH balance from [ItemAccount].
//     *
//     * @param itemAccount [ItemAccount]
//     * @return A BCH value as a long.
//     */
//    fun getBchBalance(itemAccount: ItemAccount): Long = when (itemAccount.type) {
//        ItemAccount.TYPE.ALL_ACCOUNTS_AND_LEGACY -> bchDataManager.getWalletBalance().toLong()
//        ItemAccount.TYPE.ALL_LEGACY -> bchDataManager.getImportedAddressBalance().toLong()
//        ItemAccount.TYPE.SINGLE_ACCOUNT -> bchDataManager.getAddressBalance(itemAccount.address!!).toLong()
//    }

    /**
     * Get a specific [ActivitySummaryItem] from a hash
     *
     * @param transactionHash The hash of the Tx to be returned
     * @return An Observable object wrapping a Tx. Will call onError if not found with a
     * NullPointerException
     */
//    fun getTxFromHash(transactionHash: String): Single<ActivitySummaryItem> =
//        Observable.fromIterable(getTransactionList())
//            .filter { it.hash == transactionHash }
//            .firstOrError()

//    private fun insertTransactionList(txList: MutableList<ActivitySummaryItem>) {
//        val pendingTxs = getRemainingPendingTransactionList(txList)
//        clearTransactionList()
//        txList.addAll(pendingTxs)
//        transactionListStore.insertTransactions(txList)
//    }

    /**
     * Gets list of transactions that have been published but delivery has not yet been confirmed.
     */
    private fun getRemainingPendingTransactionList(newlyFetchedTxs: ActivitySummaryList): ActivitySummaryList {
        val pendingMap = HashMap<String, ActivitySummaryItem>()
        transactionListStore.list
            .filter { it.isPending }
            .forEach { pendingMap[it.hash] = it }

        if (pendingMap.isNotEmpty()) {
            filterProcessed(newlyFetchedTxs, pendingMap)
        }

        return ArrayList(pendingMap.values)
    }

    private fun filterProcessed(
        newlyFetchedTxs: ActivitySummaryList,
        pendingMap: HashMap<String, ActivitySummaryItem>
    ) {
        newlyFetchedTxs.filter { pendingMap.containsKey(it.hash) }
            .forEach { pendingMap.remove(it.hash) }
    }
}
