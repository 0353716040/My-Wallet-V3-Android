package piuk.blockchain.android.coincore.old

import com.blockchain.sunriver.XlmDataManager
import info.blockchain.balance.CryptoCurrency
import info.blockchain.wallet.payload.PayloadManager
import io.reactivex.Observable
import io.reactivex.Single
import io.reactivex.rxkotlin.Observables
import io.reactivex.schedulers.Schedulers
import piuk.blockchain.android.ui.account.ItemAccount
import piuk.blockchain.androidcore.data.bitcoincash.BchDataManager
import piuk.blockchain.androidcore.data.erc20.Erc20Account
import piuk.blockchain.androidcore.data.erc20.FeedErc20Transfer
import piuk.blockchain.androidcore.data.ethereum.EthDataManager
import piuk.blockchain.android.coincore.model.TransactionListStore
import piuk.blockchain.android.coincore.model.ActivitySummaryItem
import piuk.blockchain.android.coincore.model.Erc20ActivitySummaryItem
import piuk.blockchain.android.coincore.model.BchActivitySummaryItem
import piuk.blockchain.android.coincore.model.XlmActivitySummaryItem

typealias ActivitySummaryList = List<ActivitySummaryItem>

class TransactionListDataManager(
    private val payloadManager: PayloadManager,
    private val ethDataManager: EthDataManager,
    private val bchDataManager: BchDataManager,
    private val xlmDataManager: XlmDataManager,
    private val paxAccount: Erc20Account,
    private val transactionListStore: TransactionListStore
) {
    fun fetchTransactions(
        cryptoCurrency: CryptoCurrency,
        itemAccount: ItemAccount,
        limit: Int = 50,
        offset: Int = 0
    ): Single<ActivitySummaryList> =
        when (cryptoCurrency) {
            CryptoCurrency.BTC -> TODO("MOVED!")
            CryptoCurrency.ETHER -> TODO("MOVED!")
            CryptoCurrency.BCH -> fetchBchTransactions(itemAccount, limit, offset)
            CryptoCurrency.XLM -> fetchXlmTransactions()
            CryptoCurrency.PAX -> getPaxTransactions().onErrorReturn { emptyList() }
            CryptoCurrency.STX -> TODO("STUB: STX NOT IMPLEMENTED")
        }.doOnNext {
            insertTransactionList(it.toMutableList())
        }
        .map { transactionListStore.list }
        .doOnError { emptyList<ActivitySummaryItem>() }
        .subscribeOn(Schedulers.io())
        .singleOrError()





    /**
     * Returns a list of [ActivitySummaryItem] objects generated by [getTransactionList]
     *
     * @return A list of Txs sorted by date.
     */
    fun getTransactionList(): ActivitySummaryList = transactionListStore.list

    /**
     * Resets the list of Transactions.
     */
    fun clearTransactionList() {
        transactionListStore.clear()
    }

    /**
     * Get total BTC balance from [ItemAccount].
     *
     * @param itemAccount [ItemAccount]
     * @return A BTC value as a long.
     */
    fun getBtcBalance(itemAccount: ItemAccount): Long = when (itemAccount.type) {
        ItemAccount.TYPE.ALL_ACCOUNTS_AND_LEGACY -> payloadManager.walletBalance.toLong()
        ItemAccount.TYPE.ALL_LEGACY -> payloadManager.importedAddressesBalance.toLong()
        ItemAccount.TYPE.SINGLE_ACCOUNT -> payloadManager.getAddressBalance(itemAccount.address).toLong()
    }

    /**
     * Get total BCH balance from [ItemAccount].
     *
     * @param itemAccount [ItemAccount]
     * @return A BCH value as a long.
     */
    fun getBchBalance(itemAccount: ItemAccount): Long = when (itemAccount.type) {
        ItemAccount.TYPE.ALL_ACCOUNTS_AND_LEGACY -> bchDataManager.getWalletBalance().toLong()
        ItemAccount.TYPE.ALL_LEGACY -> bchDataManager.getImportedAddressBalance().toLong()
        ItemAccount.TYPE.SINGLE_ACCOUNT -> bchDataManager.getAddressBalance(itemAccount.address!!).toLong()
    }

    /**
     * Get a specific [ActivitySummaryItem] from a hash
     *
     * @param transactionHash The hash of the Tx to be returned
     * @return An Observable object wrapping a Tx. Will call onError if not found with a
     * NullPointerException
     */
    fun getTxFromHash(transactionHash: String): Single<ActivitySummaryItem> =
        Observable.fromIterable(getTransactionList())
            .filter { it.hash == transactionHash }
            .firstOrError()

    private fun insertTransactionList(txList: MutableList<ActivitySummaryItem>) {
        val pendingTxs = getRemainingPendingTransactionList(txList)
        clearTransactionList()
        txList.addAll(pendingTxs)
        transactionListStore.insertTransactions(txList)
    }

    /**
     * Gets list of transactions that have been published but delivery has not yet been confirmed.
     */
    private fun getRemainingPendingTransactionList(newlyFetchedTxs: ActivitySummaryList): ActivitySummaryList {
        val pendingMap = HashMap<String, ActivitySummaryItem>()
        transactionListStore.list
            .filter { it.isPending }
            .forEach { pendingMap[it.hash] = it }

        if (pendingMap.isNotEmpty()) {
            filterProcessed(newlyFetchedTxs, pendingMap)
        }

        return ArrayList(pendingMap.values)
    }

    private fun filterProcessed(
        newlyFetchedTxs: ActivitySummaryList,
        pendingMap: HashMap<String, ActivitySummaryItem>
    ) {
        newlyFetchedTxs.filter { pendingMap.containsKey(it.hash) }
            .forEach { pendingMap.remove(it.hash) }
    }

    private fun getPaxTransactions(): Observable<ActivitySummaryList> {
        val feedTransactions =
            paxAccount.getTransactions().mapList {
                val feeObservable = ethDataManager.getTransaction(it.transactionHash)
                    .map { transaction -> transaction.gasUsed * transaction.gasPrice }
                FeedErc20Transfer(it, feeObservable)
            }

        return Observables.zip(
            feedTransactions,
            paxAccount.getAccountHash(),
            ethDataManager.getLatestBlockNumber()
        ).map { (transactions, accountHash, latestBlockNumber) ->
            transactions.map { transaction ->
                Erc20ActivitySummaryItem(
                    transaction,
                    accountHash,
                    latestBlockNumber.number
                )
            }
        }
    }



    private fun <T, R> Observable<List<T>>.mapList(func: (T) -> R): Observable<List<R>> {
        return flatMapIterable { list ->
            list.map { func(it) }
        }.toList().toObservable()
    }
}
